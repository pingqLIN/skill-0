{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://skill-parser.pingqlin.dev/schema/v2.1/skill-decomposition.schema.json",
  "title": "Skill Decomposition Schema",
  "description": "Standard format for parsing internal component structure of Claude Skills and MCP Tools, using ternary classification: Action / Rule / Directive",
  "version": "2.1.0",
  "author": "pingqLIN",
  "created": "2026-01-23",
  "updated": "2026-01-27",
  "definitions": {
    "provenance_source": {
      "type": "object",
      "description": "Source information (supports skills/tools input from different sources and quality levels)",
      "required": [
        "kind",
        "ref"
      ],
      "properties": {
        "kind": {
          "type": "string",
          "enum": [
            "claude_skill",
            "mcp_tool",
            "tool",
            "document",
            "repository",
            "web",
            "unknown"
          ],
          "description": "Source type"
        },
        "ref": {
          "type": "string",
          "description": "Source identifier (e.g., repo/path, tool name, document id, URL, etc.)"
        },
        "uri": {
          "type": "string",
          "description": "Optional: Source URI/URL"
        },
        "version": {
          "type": "string",
          "description": "Optional: Source version/commit/tag"
        },
        "author": {
          "type": "string",
          "description": "Optional: Original author/maintainer (if available)"
        },
        "retrieved_at": {
          "type": "string",
          "format": "date-time",
          "description": "Optional: Retrieved/imported time"
        },
        "checksum": {
          "type": "string",
          "description": "Optional: Content checksum (if available)"
        },
        "meta": {
          "type": "object",
          "description": "Optional: Other source metadata"
        }
      },
      "additionalProperties": true
    },
    "provenance_location": {
      "type": "object",
      "description": "Source location (can use minimal locator or more detailed structured fields)",
      "required": [
        "locator"
      ],
      "properties": {
        "locator": {
          "type": "string",
          "description": "Minimal locator string, e.g., SKILL.md#L120, docs/spec.md:3, json_pointer:/decomposition/directives/0"
        },
        "file": {
          "type": "string",
          "description": "Optional: File path"
        },
        "line_start": {
          "type": "integer",
          "minimum": 1
        },
        "line_end": {
          "type": "integer",
          "minimum": 1
        },
        "section": {
          "type": "string",
          "description": "Optional: Section/heading"
        },
        "url": {
          "type": "string",
          "description": "Optional: URL (if source is web)"
        },
        "json_pointer": {
          "type": "string",
          "description": "Optional: JSON Pointer"
        }
      },
      "additionalProperties": true
    },
    "provenance_extraction": {
      "type": "object",
      "description": "Extraction/translation method (preserves original intent while allowing backend encoding/compilation)",
      "required": [
        "method"
      ],
      "properties": {
        "method": {
          "type": "string",
          "enum": [
            "manual",
            "parser",
            "llm",
            "imported",
            "unknown"
          ],
          "description": "How source content was obtained/organized"
        },
        "extracted_at": {
          "type": "string",
          "format": "date-time",
          "description": "Optional: Extraction time"
        },
        "extracted_by": {
          "type": "string",
          "description": "Optional: Extractor/system"
        },
        "inferred": {
          "type": "boolean",
          "description": "Optional: Whether includes inference/completion (not verbatim from source)"
        },
        "confidence": {
          "type": "number",
          "minimum": 0,
          "maximum": 1,
          "description": "Optional: Confidence in translation/inference (0..1)"
        },
        "model": {
          "type": "string",
          "description": "Optional: If LLM, the model identifier used"
        },
        "tool_version": {
          "type": "string",
          "description": "Optional: Parser/translation tool version"
        },
        "notes": {
          "type": "string",
          "description": "Optional: Additional notes"
        }
      },
      "additionalProperties": true
    },
    "directive_provenance_basic": {
      "type": "object",
      "description": "Two-level provenance (basic): traceable + preserves original sentence intent (minimal fill)",
      "required": [
        "level",
        "source",
        "original_text"
      ],
      "properties": {
        "level": {
          "type": "string",
          "const": "basic"
        },
        "source": {
          "$ref": "#/definitions/provenance_source"
        },
        "original_text": {
          "type": "string",
          "description": "Original sentence/excerpt from source (preferably verbatim)"
        },
        "note": {
          "type": "string",
          "description": "Optional: Additional context"
        }
      },
      "additionalProperties": false
    },
    "directive_provenance_full": {
      "type": "object",
      "description": "Two-level provenance (full): provides location + extraction method for backend judgment and encoding",
      "required": [
        "level",
        "source",
        "original_text",
        "location",
        "extraction"
      ],
      "properties": {
        "level": {
          "type": "string",
          "const": "full"
        },
        "source": {
          "$ref": "#/definitions/provenance_source"
        },
        "original_text": {
          "type": "string",
          "description": "Original sentence/excerpt from source (preferably verbatim)"
        },
        "location": {
          "$ref": "#/definitions/provenance_location"
        },
        "extraction": {
          "$ref": "#/definitions/provenance_extraction"
        },
        "evidence": {
          "type": "array",
          "description": "Optional: Additional evidence fragments/references",
          "items": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string"
              },
              "value": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "value"
            ],
            "additionalProperties": true
          }
        }
      },
      "additionalProperties": false
    },
    "directive_provenance": {
      "description": "Provenance can be filled as basic/full depending on the situation; backend can determine encoding/translation strategy based on content quality",
      "oneOf": [
        {
          "$ref": "#/definitions/directive_provenance_basic"
        },
        {
          "$ref": "#/definitions/directive_provenance_full"
        }
      ]
    },
    "action": {
      "type": "object",
      "description": "Action: Atomic operation, indivisible. Answers 'what to do'",
      "required": [
        "id",
        "name",
        "action_type",
        "deterministic"
      ],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^a_[0-9]{3}$",
          "description": "Action identifier, format: a_001, a_002..."
        },
        "name": {
          "type": "string"
        },
        "action_type": {
          "type": "string",
          "enum": [
            "transform",
            "io_read",
            "io_write",
            "compute",
            "external_call",
            "state_change",
            "llm_inference",
            "await_input"
          ],
          "description": "Action type: transform=transformation, io_read=read, io_write=write, compute=computation, external_call=external call, state_change=state change, llm_inference=LLM inference, await_input=await input"
        },
        "description": {
          "type": "string"
        },
        "immutable_elements": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Immutable elements, changing them will alter functional semantics"
        },
        "mutable_elements": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Mutable elements (input parameters)"
        },
        "deterministic": {
          "type": "boolean",
          "description": "Whether same input necessarily produces same output"
        },
        "side_effects": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Side effects produced by executing this action"
        }
      }
    },
    "rule": {
      "type": "object",
      "description": "Rule: Atomic judgment, indivisible. Answers 'how to judge'",
      "required": [
        "id",
        "name",
        "condition_type",
        "returns"
      ],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^r_[0-9]{3}$",
          "description": "Rule identifier, format: r_001, r_002..."
        },
        "name": {
          "type": "string"
        },
        "condition_type": {
          "type": "string",
          "enum": [
            "validation",
            "existence_check",
            "type_check",
            "range_check",
            "permission_check",
            "state_check",
            "consistency_check",
            "threshold_check"
          ],
          "description": "Condition type: validation=validation, existence_check=existence check, type_check=type check, range_check=range check, permission_check=permission check, state_check=state check, consistency_check=consistency check, threshold_check=threshold check"
        },
        "condition_expression": {
          "type": "string",
          "description": "Condition expression (pseudocode or logical description)"
        },
        "returns": {
          "type": "string",
          "enum": [
            "boolean",
            "classification",
            "enum_value",
            "score"
          ],
          "description": "Return type: boolean=boolean, classification=classification, enum_value=enum value, score=score"
        },
        "fail_action": {
          "type": "string",
          "enum": [
            "halt",
            "branch",
            "default_value",
            "error_throw",
            "retry",
            "escalate"
          ],
          "description": "Action when judgment fails"
        },
        "branching_targets": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "If fail_action is branch, list possible branch targets"
        }
      }
    },
    "directive": {
      "type": "object",
      "description": "Directive: Descriptive statement, decomposable but chosen not to decompose at this level. Answers 'what state/goal/principle to describe'",
      "required": [
        "id",
        "name",
        "directive_type",
        "description"
      ],
      "properties": {
        "id": {
          "type": "string",
          "pattern": "^d_[0-9]{3}$",
          "description": "Directive identifier, format: d_001, d_002..."
        },
        "name": {
          "type": "string"
        },
        "directive_type": {
          "type": "string",
          "enum": [
            "completion",
            "knowledge",
            "principle",
            "constraint",
            "preference",
            "strategy"
          ],
          "description": "Directive type: completion=completion state, knowledge=domain knowledge, principle=guiding principle, constraint=constraint, preference=preference, strategy=strategy"
        },
        "description": {
          "type": "string",
          "description": "Descriptive statement content"
        },
        "decomposable": {
          "type": "boolean",
          "default": true,
          "description": "Whether this directive can be further decomposed into Action + Rule"
        },
        "decomposition_hint": {
          "type": "string",
          "description": "If deep parsing is needed, provide decomposition direction or reference"
        },
        "related_elements": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Related element IDs (Actions or Rules)"
        },
        "provenance": {
          "description": "Optional: Source traceability and original sentence preservation (two-level)",
          "$ref": "#/definitions/directive_provenance"
        }
      }
    },
    "execution_path": {
      "type": "object",
      "description": "Execution path: Describes execution order and conditions of elements",
      "required": [
        "path_id",
        "sequence",
        "condition"
      ],
      "properties": {
        "path_id": {
          "type": "integer"
        },
        "sequence": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Execution sequence (element IDs)"
        },
        "condition": {
          "type": "string",
          "description": "Condition that triggers this path"
        },
        "expected_outcome": {
          "type": "string"
        },
        "probability": {
          "type": "string",
          "description": "Estimated probability of this path occurring (if determinable)"
        },
        "_halt": {
          "type": "boolean"
        },
        "_note": {
          "type": "string"
        }
      }
    }
  },
  "type": "object",
  "required": [
    "meta",
    "decomposition"
  ],
  "properties": {
    "meta": {
      "type": "object",
      "required": [
        "skill_id",
        "name",
        "skill_layer",
        "schema_version",
        "parse_timestamp"
      ],
      "properties": {
        "skill_id": {
          "type": "string",
          "pattern": "^(claude|mcp)__[a-z_]+__[a-z_]+$"
        },
        "name": {
          "type": "string"
        },
        "skill_layer": {
          "type": "string",
          "enum": [
            "claude_skill",
            "mcp_tool",
            "mcp_server_internal"
          ],
          "description": "Skill layer"
        },
        "server": {
          "type": "string"
        },
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "schema_version": {
          "type": "string",
          "description": "Schema version used"
        },
        "parse_timestamp": {
          "type": "string",
          "format": "date-time"
        },
        "parser_version": {
          "type": "string"
        },
        "parsed_by": {
          "type": "string",
          "description": "skill_id that performed the parsing"
        }
      }
    },
    "original_definition": {
      "type": "object",
      "description": "Original definition (MCP Tool or Claude Skill description)"
    },
    "decomposition": {
      "type": "object",
      "description": "Ternary classification decomposition result",
      "properties": {
        "actions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/action"
          },
          "description": "Action list: atomic operations, indivisible"
        },
        "rules": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/rule"
          },
          "description": "Rule list: atomic judgments, indivisible"
        },
        "directives": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/directive"
          },
          "description": "Directive list: descriptive statements, parsing boundary"
        }
      }
    },
    "execution_paths": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/execution_path"
      },
      "description": "Execution path list"
    },
    "parser_meta": {
      "type": "object",
      "description": "Parser metadata",
      "properties": {
        "paths_enumerated": {
          "type": "integer"
        },
        "max_paths_exceeded": {
          "type": "boolean"
        },
        "max_paths_limit": {
          "type": "integer",
          "default": 100
        },
        "halt_reason": {
          "type": [
            "string",
            "null"
          ]
        },
        "decomposition_depth": {
          "type": "integer",
          "description": "Parsing depth level"
        },
        "directives_expandable": {
          "type": "integer",
          "description": "Number of directives that can be further expanded"
        },
        "requires_deep_parse": {
          "type": "boolean"
        },
        "deep_parse_trigger": {
          "type": "string",
          "description": "Reason that triggered deep parsing"
        },
        "inconsistency_detected": {
          "type": "boolean"
        },
        "inconsistency_detail": {
          "type": "string"
        }
      }
    }
  }
}
